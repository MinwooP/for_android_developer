## Do It! Kotlin Programming Ch1

코틀린은 다음과 같이 프로그래밍이 가능한 멀티플랫폼 언어이다.

+ Kotlin/JVM : **자바 가상 머신에서 동작하는 애플리케이션**을 만들 수 있다.
+ Kotlin/JS : **자바 스크립트로 웹 브라우저에서 동작하는 애플리케이션**을 만들 수 있다.
+ Kotlin/Native : LLVM 컴파일러를 이용하여 여러 플랫폼을 타깃으로 하는 애플리케이션을 만들 수 있다. 

=> 이 책에서는 **Kotlin/JVM**을 이용해 코틀린을 학습할 것



코틀린의 장점

+ 자료형 오류를 미리 잡을 수 있는 **정적 언어**이다.

  프로그램이 컴파일될 때 자료형을 검사하여 확정하는 정적 언어 => 프로그램의 안정성 증가

+ `NullPointerException`으로 인한 프로그램의 중단을 예방할 수 있다. 

  `NullPointerException`은 프로그램이 실행되는 도중에 발생하기 때문에 언제 어디서 어떻게 발생할지 아무도 알 수 없다. 하지만 코틀린은 이를 예방할 수 있다.

+ 간결하고 효율적이다.

+ 함수형 프로그래밍과 객체 지향 프로그래밍 모두 가능하다.

  함수를 변수에 저장하거나 함수를 다른 함수의 매개변수로 넘길 수 있는 함수형 프로그래밍과 클래스를 사용하는 객체 지향 프로그래밍을 둘다 할 수 있다. 

  => 이런 특징을 '**다중 패러다임 언어**' 라고 부른다.



JDK 설치

C:\Program Files\Zulu\zulu-8\

JDK, intellij 설치 완료 후 프로젝트 생성 후, file 만들어서 예제 실행했는데 뭔가 꼬인듯. 실행이 안됨



32p)



#### 코틀린의 main() 함수는 프로그램의 실행 진입점

자바 같은 객체 지향 언어에서 프로그램을 실행하려면 최소한 하나의 클래스와 그 안에 main() 함수가 있어야 한다. 하지만 **코틀린은 선언한 클래스가 없는데도 불구하고 main()함수와 println() 함수를 통해 콘솔에 문자열 "Hello Kotlin"을 출력한다.**

작성한 **코틀린 코트는 JVM에서 실행되며, main() 함수가 있는 파일 이름을 기준으로 자바 클래스가 자동 생성**된다. 



자동생성된 자바 클래스를 확인하는 것을 역컴파일이라고 한다.

생성된 소스에서 main() 메서드를 보면 `HelloKotlinKT` 클래스 안에 속한 멤버 메서드로 선언되어 있는 것을 알 수 있다. 이것은 JVM에 실행되기 위해 문자열은 **String var0**으로 선언되어 **System.out.println()**에 의해 콘솔 장치에 출력되는 것이다.  



변환된 main() 메서드의 의미

```kotlin
public static void main(String[] var0){
```

+ public : 가시성 지시자로 **HelloKotlinKt** 클래스의 외부 어디에서도 접근할 수 있다는 의미
+ static : 이 메서드가 정적 메서드임을 나타냄. static으로 선언하면 프로그램의 정적 메모리 영역에 객체가 만들어지기 때문에 객체의 생성 없이 호출해 사용할 수 있게 된다. 
+ final : 최종 메서드 임을 나타냄
+ void : 메서드가 반환할 것이 없는 경우

<br>

> 34p) 프로그램의 메모리 영역 다시 보기
>
> JVM을 사용하는 프로그램에는 동적 메모리 영역의 객체가 사용된 뒤 아무 참조가 없으면 자동으로 삭제하는 GC(Garbage Collector)가 있다. 일종의 쓰레기 청소부 역할을 해주며, 우리도 모르게 쓸모없는 객체를 치워주는 일을 한다.

<br>

#### 코틀린의 main() 메서드에서 매개변수를 사용할 경우

main() 메서드에서 매개변수 `args: Array<String>`을 사용하면 자바에서는 `String[] args`로 변환됩니다. 이 `args`는 main()에 전달할 외부의 인자들을 가리키고, command line에서 입력받은  값들이 차례로 배열에 들어가게 됩니다.

