# 안드로이드 아키텍쳐

#### 디자인 패턴이란

> 소프트웨어 개발 방법에서 사용되는 **디자인 패턴**은, 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식을 설명해 준다. 
>
> [위키피디아](https://ko.wikipedia.org/wiki/디자인_패턴)

+ 소프트웨어의 개발 방법을 문서로 공식화 한 것

+ 디자인 패턴을 사용하지 않으면, **서로 간의 의존성이 강해지기** 때문에 유지 보수가 힘들어진다.

<br><br>

-----

## 1️⃣ MVC

#### 📌 MVC란 ?

+ MVC는 안드로이드와 관계없이 프로그래밍 시 가장 널리 사용되는 구조 중 하나이며 간단하게 **Model, View, Control**의 약자입니다.

+ MVC 구조에서의 입력은 모두 Control에서 발생하게 되며 관리되게 되는 구조입니다.
  이벤트가 발생한 Control에 의해 각 모듈의 정의와 View의 사용 용도가 달라지게 됩니다

<br>

#### 📌 MVC 구조

- **Model**
  - 데이터를 가지며 애플리케이션에서 사용되는 데이터와 그 데이터를 처리함.
  - View 또는 Control에 묶이지 않아 재사용 가능함.
- **View**
  - 사용자에게 보일 화면을 표현.
  - 앱 및 UI와의 상호작용에서 컨트롤러와 통신함.
  - 유저가 어떤 입력(Action)을 하든 View는 무엇을 해야 할지 모름
- **Control**
  - 사용자로부터 입력을 받고 이 입력을 모델에 의해 View 정의를 하게 됨.
  - 모델의 데이터 변화에 따라 뷰를 선택함.

<br>

#### 📌 MVC의 장점

- Model과 View의 분리됨.
- Model의 비종속성으로 재사용 가능함.
- 구현하기 가장 쉽고 단순함.
- 유닛테스트에서 View는 테스트 할 부분이 없기 때문에 쉽게 Model만 테스트 가능.
- 개발자라면 누구나 쉽게 파악 가능함.
- 개발기간이 짧아짐. **(안드로이드에서의 장점)**
  그냥 다른거 생각할것 없이 안드로이드 액티비티에서 모든 걸 다 동작하게 처리만 잘 해주면 개발 기간이 짧아질수도 있다.

<br>

#### 📌 MVC의 단점

- Model과 View사이에 의존성 발생함. (서로간의 의존성 완전히 없앨 수 없음)
  즉, View의 UI 갱신을 위해 Model을 직/간접적으로 참조하므로 앱 자체가 커지고 로직이 복잡해질수록 유지보수가 힘들어집니다.
- 스파게티 코드가 될 가능성이 높음.
  코드 복사/붙여넣기가 많아지게 되면서 코드 분리조차 되지않으면 코드가 아주 제대로 꼬여버립니다. 그렇기에 복잡도는 증가합니다. 다만, 이는 설계 단계에서 제대로해서 분리를 잘하면 어느정도 해소는 됩니다.
- 시간이 지날수록 컨트롤러에 많은 코드가 쌓여 코드가 비대화하여 문제 발생 가능
- Controller가 안드로이드 API에 깊게 종속되므로 유닛 테스트가 어려움.

<br><br>

-----

## 2️⃣ MVP

#### 📌 MVP란 ?

+ MVP 패턴이란 **Model, View, Presenter**의 첫 글자를 따서 이름이 지어졌습니다. MVP의 핵심 설계는 MVC와는 다르게 **UI(View)와 비즈니스 로직(Model)을 분리**하고, 서로 간에 상호작용을 다른 객체(Presenter)에 그 역할을 줌으로써 **서로의 영향(의존성)을 최소화**하는 것에 있습니다.

<br>

#### 📌 MVP 구조

- Model
  - 프로그램 내부적으로 쓰이는 데이터를 저장하고, 처리하는 역할을 함.(비즈니스 로직)
  - View 또는 Presenter 등 다른 어떤 요소에도 의존적이지 않은 독립적인 영역임.
- View
  - UI를 담당하며 안드로이드에서는 Activity, Fragment가 대표적인 예.
  - Model에서 처리된 데이터를 Presenter를 통해 받아서 유저에게 보여줌.
  - 유저 액션(Action) 및 액티비티 라이프사이클 상태 변경을 주시하며 Presenter에 보내는 역할임.
  - Presenter를 이용해 데이터를 주고받기 때문에 Presenter에 매우 의존적임.
- Presenter
  - Model과 View사이의 매개체.
  - 모델과 뷰의 매개체라는 점에서 Controller와 유사하지만, ***View에 직접 연결되는 대신 인터페이스를 통해 상호작용*** 한다는 점이 다름.
  - 인터페이스를 통해 상호작용 하므로 MVC가 가진 테스트 문제와 함께 모듈화/유연성 문제 역시 해결할 수 있음.
  - 뷰에게 표시할 내용(Data)만 전달하며 어떻게 보여줄지는 View가 담당.

<br>

#### 📌 MVP의 장점

+ MVC 와는 다르게 코드가 매우 깔끔 해지며 MVP를 이용해서 이와 같이 **Model과 View 간의 결합도를 낮추면**, 새로운 기능 추가 및 변경을 해야 할 때 관련된 해당 부분만 코드 수정하면 되기 때문에 확장성이 좋아짐과 동시에 **유닛 테스트 시 테스트 코드를 작성하기 편리**해지기 때문에 더 쉽게 안전한 코딩이 가능해집니다.
+ 그리고 UI, Data 각각 파트를 나누기 때문에 해야 할 일이 명확해지고 그 결과로 쉽고 빠르게 코딩이 가능합니다.

<br>

#### 📌 MVP의 단점

+ 가장 큰 단점은 애플리케이션이 복잡해질수록 View와 Presenter 사이의 의존성이 강해지는 단점이 있습니다.
+ 그리고 MVC의 Controller처럼 Presenter도 어느 정도 시간이 지남에 따라 추가 비즈니스 로직이 집중되는 경향이 있습니다. 개발자는 시간이 지난 어느 순간 거대해지며 동시에 다루기도 어렵고, 문제가 발생하기 쉽고, 서로 간의 분리를 하기도 어려운 Presenter를 발견하게 됩니다. 물론 초기에 설계/기획을 잘함과 동시에 유능한 개발자라면 시간의 흐름에 따른 앱의 다양한 변화에 맞춰서 이 문제를 해결해나갈 수 있겠지만 실제로는 그것도 쉽지만은 않습니다.

<br><br>

-----

## 2️⃣ MVVM

#### 📌 MVVM이란 ? 

+ **MVVM 패턴이란 Model, View, ViewModel의 줄임말입니다.** 하나의 소프트웨어를 최대한 기능적으로 작은 단위로 나누어 테스트가 쉽고 큰 프로젝트도 상대적으로 관리하기가 좋은 구조입니다.
+ 모든 입력(Input)들은 View로 전달되며 ViewModel은 입력에 해당하는 Presentation Logic을 처리하여 View에 데이터를 전달합니다. ViewModel은 View를 따로 참조하지 않기 때문에 독립적이며 **ViewModel과 View는 1:n**의 관계입니다.
+ 따라서 View는 자신이 이용할 ViewModel을 선택해 데이터를 바인딩하여 업데이트를 받게 됩니다. 그 후 Model이 상태 및 데이터가 변경되면 해당하는 ViewModel을 이용하는 View가 자동으로 업데이트됩니다. 마지막으로 ViewModel은 View를 나타내기 위한 Model이자, View의 Presentation Logic을 처리합니다. 
+ MVP와 마찬가지로 M-V 사이의 의존성이 없고, MVP처럼 V-VM이 1:1 관계가 아닌 독립적이기 때문에 이 둘 사이의 의존성도 없습니다.
+ MVP 패턴에서는 View와 Presenter가 강하게 결합하여 있다는 문제점이 있었지만, MVVM 패턴에서는 데이터 바인딩 및 LiveData와 같은 observable 타입을 이용하여 Presenter와 View 사이에서 강하게 연결되었던 점을 끊는데 집중한다. 
+  



#### 📌 MVVM 구조

- View
  - View는 Activity나 Fragment 같은 화면에 표현되는 레이아웃을 정의함.
  - **View는 기본적으로 데이터를 보여주기만 해야 해서 비즈니스 로직을 포함하지 않지만 UI 변경과 관련된 일부 로직은 포함될 수 있음.(안드로이드는 다른 플랫폼과는 다르게 생명주기(lifecycle)이라는 특수한 순서(Flow)를 가지고 있기 때문에 이것을 처리하는 것만으로도 View는 상당히 복잡해지기 때문임.)**
  - **View는 ViewModel을 관찰하고 있다가 상태 변화가 전달되면 화면을 갱신해야 함.**
- ViewModel
  - View와 Model 사이의 매개체 역할을 함.
  - View와 Model을 연결함. Model에서 데이터를 가져와 저장하고 View에서는 ViewModel의 데이터를 가져와 사용한다. Observer 패턴으로 View는 ViewModel을 관찰하고 있다가 데이터가 변경되면 UI를 갱신하는데, 이때 보통 LiveData를 사용한다.
  - **모든 View와 관련된 비즈니스 로직은 이 곳에 들어가게 되며 데이터를 잘 가공해서 View에서 뿌리기 쉬운 Model로 바꾸는 역할을 함.**
  - View와 ViewModel은 MVP와는 다르게 1:n의 관계를 가질 수 있으며 여러 개의 Fragment가 하나의 ViewModel을 가질 수 있음.
  - ViewModel은 View가 데이터 바인딩(Data Binding)할 수 있는 속성과 명령으로 구성되어 있음.
- Model
  - MVC의 Model과 역할은 동일함.
  - DataModel이라고도 하며 DB, Network, SharedPreference 등 다양한 데이터 소스로부터 필요한 데이터를 준비함.
  - ViewModel에서 데이터를 가져갈 수 있게 데이터를 준비하고 그에 대한 "이벤트"를 보냄.

<br>

#### 📌 MVVM의 동작 방식

1. View에 Event가 발생
2. Event가 DataBinding 또는 Listener를 통해서 ViewModel에 전달
3. ViewModel은 Model에 데이터 요청
4. ViewModel은 CallBack으로 데이터를 수신
5. ViewModel은 받은 데이터를 가공해 저장
6. View는 ViewModel의 데이터를 관찰해(Observe) UI 갱신

**MVVM 구조에서는 View는 ViewModel을 알지만 반대로 ViewModel은 View를 알면 안된다.** 그래서 View가 ViewModel을 관찰하면서 UI를 갱신을 하게된다.



> 참고 - [JOJO_Devstory](https://velog.io/@jojo_devstory/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-MVVM%EC%9D%B4-%EB%AD%98%EA%B9%8C)