# Do It! Kotlin Programming Ch3

## 🚩 3 - 1 함수 선언하고 호출하기

### 함수란?

함수란 일종의 **장치**이다. 

1. 여러 값을 입력받아 

2. 기능을 수행하고

3. 결과값을 반환한다.

```kotlin
fun sum(a:Int, b:Int): Int{
    var sum = a+b
    return 
}

==


fun sum(a:Int, b:Int): Int{
    return a+b
}

==
// 중괄호 안의 코드가 한 줄이면 중괄호와 return문 생략 가능
fun sum(a:Int, b:Int) = a + b
```

<br><br>

### 함수의 호출과 메모리

프로그램이 실행되면 `main()`함수가 가장 먼저 실행되고 중괄호로 감싼 본문 코드가 실행된다. 그러면 `main()` 함수의 본문인 **중괄호 안의 변수는 어디에 어떻게 저장**되나?

프로그램이 실행되면 메모리에 프로그램을 위한 공간이 만들어진다. 

```kotlin
fun main(){ // 최초의 스택 프레임
    val num1 = 10
    val num2 = 3
    val result: Int
    
    result = max(num1, num2) // 두 번째 스택 프레임
}

fun max(a: Int, b: Int) = if(a>b) a else b 
```

<br>

#### 함수와 스택 프레임

다음 그림은 main() 함수와 max() 함수가 순서대로 호출된 이후의 메모리 상태를 나타낸다.
이때, 함수의 각 정보는 프레임이라는 정보로 **스택 메모리의 높은 주소부터** 거꾸로 자라듯이 채워져 간다.

<img src = "https://user-images.githubusercontent.com/31370590/138798734-a977a687-bc45-419b-acc7-2262ff7d4071.PNG">

main() 함수 본문인 중괄호 안에 있는 지역변수(args, num1, num2, result)는 첫 번째 스택 프레임에 들어있다. 지역 변수란 함수가 종료되면 스택 프레임과 함께 사라지는 임시변수이다.

<br>

#### 스택 프레임의 생성과 소멸

함수가 호출될때마다 해당 정보는 스택 메모리에 쌓이는데 이를 스택 프레임이라고 부른다. 

<img src = "https://user-images.githubusercontent.com/31370590/138799214-c4963005-34b0-4e06-b064-ba27f325d27d.PNG">

함수가 호출되면 스택에 프레임이 생기고 이는 각각 분리되어 있으므로 함수에 선언된 변수도 분리하여 생각하다. 그래서 프레임으로 분리된 변수들을 지역변수라고 부른다. 

예를 들어 위 그림에서 `main()`함수와 `max()`함수에 선언된 변수 중 c라는 이름의 변수가 있어도 두 변수는 다른 프레임에 있기 때문에 프로그램 실행에는 문제가 없다. 각 단계는 프레임이 만들어지고 없어지는 과정을 보여주고 각 단계에 따라서 제일 아래부터 프레임이 쌓아 올려지며 함수가 종료되면 쌓였던 프레임이 사라지고 지역 변수들도 같이 삭제된다.  

함수를 호출하면 위와 같은 방식으로 스택에 스택 프레임이 생성되며 생성한 순서의 반대 순서로 소멸된다. 예를 들어 함수 A(), B(), C()를 순서대로 호출했다면 3개의 스택 프레임이 아래에서 위로 생성되고 C(), B(), A() 순서로 스택에서 소멸된다. 

> 프레임은 스택에 생성되고 스택은 메모리의 높은 주소에서 낮은 주소 방향으로 생성된다. 힙 영역에는 동적으로 생성된 객체의 정보가 담겨져 있고 힙에서는 보통 낮은 주소에서 높은 주소로 자라가며 정보를 저장한다. 그래서 두 영역이 만나지 않도록 메모리를 관리하는 것이 중요하다. 무한하게 함수를 호출해 스택 프레임을 생성하면 스택 영역의 경계를 넘어가면서 힙 영역과 겹치게 되는데 바로 이때 바로 스택 오버플로(Stack Overflow) 오류가 발생한다.

<br>

### 매개변수의 개수가 고정되지 않은 함수

가변 인자를 사용 하면 함수는 하나만 정의해놓고 여러 개의 인자를 받을 수 있음 

가변 인자 : 인자의 개수가 변한다

```kotlin
fun normalVarargs(vararg counts: Int){
    for(num in counts){
        print("$num")
    }
    print("/n")
}
```

<br><br>

## 🚩 3 - 2 함수형 프로그래밍

112p)

코틀린은 함수형 프로그래밍과 객체 지향 프로그래밍을 모두 지원하는 다중 패러다임 언어이다. 함수형, 객체 지향 프로그래밍의 장점은 코드를 간략하게 만들 수 있다는 것이다. 

<br>

### 함수형 프로그래밍이란?

**순수 함수를 작성**하여 프로그램의 부작용을 줄이는 프로그래밍 기법을 말한다. 함수형 프로그래밍에서는 **람다식**과 **고차함수**를 사용할 수 있다.

<br>

#### 순수 함수

만일 어떤 함수가 **같은 인자에 대하여 항상 같은 결과를 반환**하면 '부작용이 없는 함수'라고 말한다. 그리고 **부작용이 없는 함수가 함수 외부의 어떤 상태도 바꾸지 않는다면** 순수 함수라고 부른다. 

이런 특성 덕분에 순수 함수는 스레드에 사용해도 안전하고 코드를 테스트하기 쉽다는 장점이 있다. 순수 함수는 부작용이 없어 값이 예측 가능해 '결정적(deterministic)' 이라고 하기도 한다. 

```kotlin
// 순수 함수의 예
fun sum(a: Int, b: Int): Int{
	return a + b // 동일한 인자인 a, b를 입력받아 항상 a+b를 출력(부작용이 없음)
}
```

위의 함수는 매개변수 a, b를 이용하여 덧셈 연산을 한 다음 그 값을 그대로 반환한다. 똑같은 값이 인자로 전달되면 반환 값도 항상 같다는 것을 예측할 수 있다. 또 함수 안에서 함수 외부의 어떤 변수 상태도 바꾸지 않는다. 

> 순수 함수가 아닌 함수
>
> ```kotlin
> fun check(){
>     val test = User.grade()
>     if (test != null)
>     	process(test)
> }
> ```
>
> `check()` 함수는 함수 안에서 함수 외부에 있는 User 객체의 함수인 grade() 함수를 실행하고 있다. 또 grade() 함수의 결과값을 test에 저장하여 if문에 사용한다 . 심지어 process() 함수는 조건을 만족하지 못하면 실행되지 않는다. check() 함수만 보면 User가 어떤 객체인지, grade() 함수는 어떤 값을 반환하는지 process() 함수는 대체 무엇을 하는지 알 수 없다.  
>
> 즉, check() 함수의 실행결과를 예측하기 어렵다.

<br><br>

### 람다식

```kotlin
{x, y -> x + y} // 람다식의 예(이름이 없는 함수 형태)
```

수학에서 말하는 람다 대수는 **이름이 없는 함수로 2개 이상의 입력을 1개의 출력으로 단순화한다는 개념**이다. 

함수형 프로그래밍의 람다식은 다른 함수의 인자로 넘기는 함수, 함수의 결과값으로 반환하는 함수, 변수에 저장하는 함수를 말한다.

<br>

#### 일급 객체

함수형 프로그래밍에서는 **함수를 일급 객체**(First Class Citizen)로 생각한다.

람다식 역시 일급 객체의 특징을 가지고 있다. 

#### 일급 객체의 특징

+ **함수의 인자**로 전달할 수 있다. 
+ **함수의 반환 값**에 사용할 수 있다.
+ **변수**에 담을 수 있다

만약 함수가 일급 객체면 일급 함수라고 부른다. 그리고 일급 함수에 이름이 없는 경우 람다식 함수 혹은 람다식이라고 부른다. 즉 **람다식은 일급 객체의 특징을 가진 이름 없는 함수**이다. 

<br>

#### 고차 함수

고차 함수란 다른 함수를 **인자로 사용**하거나 함수를 **결과값으로 반환**하는 함수를 말한다. **일급 객체 혹은 일급 함수를 서로 주고 받을 수 있는 함수**가 고차 함수가 되는 것이다.

```kotlin
fun main() {
println(highFunc({ x,y -> x+y}, 10, 20))
}

fun highFunc(sum: (Int, Int) -> Int, a:Int, b:Int): Int = sum(a, b)
```

`fun highFunc(sum: (Int, Int) -> Int, a:Int, b:Int): Int = sum(a, b)`

<img src = "https://user-images.githubusercontent.com/31370590/138803271-45c36f24-af34-4c38-bc7f-5e23d61a0e50.PNG">

<br><br>

## 🚩 3 - 3 고차 함수와 람다식

### 고차 함수의 형태

고차 함수는 인자나 반환값에 함수를 사용해서 대단히 유연하다. 이 때 함수는 일반적으로 이름이 있는 함수일 수도 있고 이름이 없는 함수일 수도 있다. 

<br>

#### 일반 함수를 인자나 반환값으로 사용하는 고차 함수

함수의 인자로 함수를 사용

```kotlin
// 함수의 인자로 함수를 사용
fun main(){
    val res1 = sum(3,2) 
    val res2 = mul(sum(3,3) 3) // 인자에 함수를 사용 
}

fun sum(a: Int, b: Int) = a + b
fun mul(a: Int, b: Int) = a * b
```

<br>

함수의 반환값으로 함수를 사용

```kotlin
// 함수의 반환값으로 함수를 사용
fun main(){
    println("function: ${funcFunc()}")
}

fun sum(a: Int, b: Int) = a + b

fun funcFunc(): Int{
    return sum(2, 2) // 반환값에 함수를 사용
}
```

<br>

#### 람다식을 인자나 반환값으로 사용하는 고차함수 

##### 람다식을 변수에 할당하는 경우

```kotlin
val multi = {x:Int, y:Int -> x * y} // 일반 변수에 람다식 할당
result = multi(10, 20) // 람다식이 할당된 변수는 함수처럼 사용 가능
```

+ 람다식이 변수에 할당되어 변수 이름을 `multi()`와 같이 함수 형태로 사용할 수 있게 된다.

<img src = "https://user-images.githubusercontent.com/31370590/139078372-b11faa24-5fa5-411a-982c-fe706213a4da.PNG">

+ 람다식의 매개변수에 자료형이 지정되어 있다면 변수의 자료형은 생략할 수 있다.

  ```kotlin
  val multi: (Int, Int) -> Int = {x:Int, y:Int -> x * y} // 생략되지 않은 전체 표현
  val multi = {x:Int, y:Int -> x * y} // 변수의 선언 자료형 생략
  val multi: (Int, Int) -> Int = {x, y -> x * y} // 람다식 매개변수 자료형의 생략 
  
  val multi = {x, y -> x * y} // 이는 불가능
  ```

  하지만 변수의 자료형과 매개변수의 자료형을 모두 생략한다면 **추론할 수 없기에** 안된다.

<br>

+ 반환자료형이 아예 없는 경우

  ```kotlin
  val greet: () -> Unit = {println("Hello World!")} // 매개변수와 반환값이 없는 경우
  ```

<br>

+ 람다식 안에 람다식을 넣는 경우

  ```kotlin
  val nestedLamda: () -> () -> Unit = {{println("nested")}}
  ```

  + 아무것도 없는 람다식 `{}`에 람다식`{println("nested")}`를 넣었다. 그러면 자료형은 `( ) -> ( ) -> Unit`으로 명시해야 한다. 

<br><br>

##### 람다식을 매개변수에 사용한 고차 함수의 경우

```kotlin
fun main() {
    result = highOrder({x,y -> x + y}, 10, 20) // 람다식을 인자로 사용
}

fun highOrder(sum: (Int, Int) -> Int, a: Int, b: Int): Int{ // 람다식을 매개변수에 사용
    return sum(a, b) 
}
```

<img src = "https://user-images.githubusercontent.com/31370590/139085114-a9c8180d-e296-47b5-a631-f658a3f3ae9a.PNG">

+ 1번에서 `highOrder()` 함수를 호출한다. 이 때, 첫 번째 인자에 람다식 `{x, y -> x + y}`를 사용했고 두번째, 세번째 인자 10, 20은 일반적인 정숫값입니다. 첫 번째 인자의 람다식은 `highOrder()` 함수의 첫 번째 매개변수에서 선언한 자료형으로 구성해야 한다.

<br><br>

##### 인자와 반환값이 없는 람다식

```kotlin
val out: ()  -> Unit = {println("Hello World!")} // 인자와 반환값이 없는 람다식의 선언 
// 자료형 추론이 가능하므로 
==
val out = {println("Hello World!")} // 와 같이 생략 가능

out( ) // 함수처럼 사용 가능
val new = out // 람다식이 들어 있는 변수를 다른 변수에 할당
new()
```

+ 이름이 없는 함수를 표현하기 위해 등장한 람다식 표현은 함수형 프로그래밍에서 아주 중요한 개념이다. 람다식은 많은 코드들을 간략화하고 함수 자체를 인자나 매개변수로 이용할 수 있어 프로그램의 효율성도 높일 수 있다.

<br><br>

### 람다식과 고차 함수 호출하기

함수의 내용을 할당하거나 인자 혹은 반환값을 자유롭게 넘기려면 호출 방법을 이해해야 한다. 

+ 기본형 변수로 할당된 값은 스택에 있고 다른 함수에 인자로 전달하는 경우에는 **해당 값이 복사되어 전달**된다.
+ 참조형 변수로 할당된 객체는 참조 주소가 스택에 있고 객체는 힙에 있다. 참조형 객체는 함수에 전달될 때 **참조된 주소가 복사되어 존달**된다. 

JVM에서 실행되는 자바나 코틀린은 함수를 호출할 때 인자의 값만 복사하는 **값에 의한 호출(Call by value)**가 일반적이다. C/C++에서 사용하는 포인터 주소 연산이 없기 때문에 주소 자체를 사용해 호출하는 **참조에 의한 호출(Call by Reference)**는 자바나 코틀린에서 사용되지 않는다. 자바는 객체가 전달될 때 주소 자체를 전달하는 것이 아닌 값을 복사하는데 이는 Call by Reference처럼 보이지만 그 값이 주소일 뿐이다. 코틀린은 람다식을 사용하면서 몇 가지 확장된 호출 방법을 사용할 수 있다. 

<br>

#### 값에 의한 호출

함수가 또 다른 함수의 인자로 전달될 경우 **람다식 함수는 값으로 처리되어 그 즉시 함수가 수행된 후 값을 전달**한다. 

```kotlin
val result = callByValue(lamda()) // 람다식 함수 호출
println(result)

fun callByValue(b: Boolean): Boolean { // 일반 변수 자료형으로 선언된 매개변수
	println("callByValue function")
	return b
}

val lamda: ( ) -> Boolean = { // 람다 표현식이 2줄
	println("lamda function")
	true // 마지막 표현식 문장의 결과가 반환
}
```

<br>

<img src = "https://user-images.githubusercontent.com/31370590/139091865-024f3393-f12c-4d52-bcb2-d5fec5cee993.PNG">

<br>

#### 이름에 의한 람다식 호출

람다식의 이름이 전달될 때 실행되지 않고 **실제로 호출할 때 실행되도록**"

```kotlin
val result = callByValue(otherLamda) // 람다식 이름으로 호출
println(result)

fun callByName(b: ( ) -> Boolean): Boolean { // 람다식 자료형으로 선언된 매개변수
	println("callByValue function")
	return b()
}

val otherLamda: ( ) -> Boolean = {
	println("lamda function")
	true // 마지막 표현식 문장의 결과가 반환
}
```

+ 위의 `callByName()` 함수의 매개변수는 `b : Boolean`으로 일반 변수 자료형으로 선언되었는데, `callByName()` 함수의 매개변수는 `b : ( ) -> Boolean`으로 람다식 자료형으로 선언되었다.

<br>

<img src = "https://user-images.githubusercontent.com/31370590/139093020-c8282afd-1c71-4bc8-84ca-ca91d7de5b21.PNG">

+ 람다식 이름을 `callByName()` 함수의 인자로 넣어 사용하고 있고 람다식 자체가 매개변수 `b`에 복사되어 사용되기 전까지는 람다식이 실행되지 않는다. 즉, 2번처럼 함수 형태로 호출해야 비로소 람다식이 실행된다. 이름이 전달된 시점이 아니라 `callByName()` 함수 블록에 사용되는 `b( )`에 의해 호출된다는 것이다. 이를 잘 활용하면 ***상황에 맞춰 즉시 실행할 필요가 없는 코드를 작성하는 경우 이름에 의한 호출 방법을 통해 필요할 때만 람다식이 작동하도록 만들 수 있다.***

<br><br>

#### 다른 함수의 참조에 의한 일반 함수 호출

지금까지는 람다식을 매개변수로 사용해 선언해 사용, 이제 람다식이 아닌 **일반 함수**를 또 다른 함수의 인자에서 호출하는 고차 함수의 경우를 보자. 

```kotlin
fun sum(x: Int, y: Int) = x + y
```

```kotlin
funcParam(3, 2, sum) // 고차 함수 - 
...
fun funcParam(a: Int, b: Int, c: (Int, Int) -> Int): Int{
    return c(a, b)
} 
```

`sum()` 함수는 람다식이 아니므로 이처럼 `funcParam(3, 2, sum)` 이름으로 호출할 수 없다. 하지만 **일반 함수 `sum()`**와 **람다식을 매개변수에 사용한 고차함수`funcParam()`**의 매개변수 c의 선언부 구조를 보면 인자 수와 자료형의 개수가 동일히다. 이때는 다음과 같이 2개의 콜론(`::`) 기호를 함수 이름 앞에 사용해 소괄호와 인자를 생략하고 사용할 수 있다. 

```kotlin
funcParam(3, 2, ::sum)

==
funcParam(3, 2, {x, y -> text(x, y)}) // ?
```

즉 매개변수와 인자 구조가 동일한 경우 람다식 표현법이 간략화된 함수 참조 기호인 `::`를 사용하면 좀 더 편리하게 작성할 수 있다. 

<br><br><br>

### 람다식과 매개변수

매개변수 개수에 따라 람다식을 구성하는 방법

=> 람다식이 매개변수로 사용될 때, 개수에 따라 => 호출할 때 어떻게 달라지는지

1. 람다식의 매개변수가 없는 경우
2. 람다식의 매개변수가 1개인 경우

```kotlin
oneParam({a-> "Hello World! $a "})
==
oneParam { "Hello World! $it"}
...

fun oneParam(out:(String) -> String) {
    println(out("OneParam"))
}
```

+ `fun oneParam(out:(String) -> String) { ~}` : 람다식을 매개변수로 사용한 고차함수이고, 매개변수의 개수는 1개이고, 이 매개변수는 람다식이다. 
+ `oneParam({a-> "Hello World! $a "})` : 위의 `oneParam()` 함수를 `{a-> "Hello World! $a "}`라는 람다식을 인자로 전달해 호출한 것이다. 
+ 이렇게 매개변수가 1개인 경우에는 화살표 표기를 생략하고 `$it`으로 대체할 수 있다. `$it`은 람다식 매개변수로 지정된 String형과 매칭되어 "OneParam" 문자열로 바뀌며 최종적으로 "Hello World! OneParam"을 출력한다.

<br>

3. 람다식의 매개변수가 2개인 경우

```kotlin
moreParam { _, b -> "Hello World! $b"}
```

+ 특정 람다식의 매개변수를 사용하고 싶지 않을 때는 이름 대신에 언더스코어(_)로 대체할 수 있다.

<br><br><br>



## 🚩 3 - 4 고차 함수와 람다식의 사례 알아보기

### 동기화를 위한 코드 구현

+ **동기화**란 변경이 일어나면 안되는 특정 코드를 보호하기 위한 잠금 기법으로, 동기화로 보호되는 코드는 **임계 영역** 이라고도 부른다. 이 코드에서는 Lock을 활용해 임계 영역을 보호하고 있다. 보통 프로그래밍에서는 **특정 공유 자원에 접근**한다고 했을 때 공유 자원이 여러 요소에 접근해서 망가지는 것을 막기 위해 **임계 영역의 코드를 잠가 두었다가 사용한 후 풀어줘야 한다**. 

+ 자바에서 Lock과 ReentrantLock

<img src = "https://user-images.githubusercontent.com/31370590/139111664-f2569f78-55e6-46ae-b058-15ba6081fd52.PNG"''>

<br>

### 네트워크 호출 구현

네트워크로부터 무언가를 호출하고 성공하거나 실패했을 때 특정 콜백 함수를 처리하는 프로그램

> 콜백 함수란? 
>
> 특정 이벤트가 발생하기까지 처리되지 않다가 이벤트가 발생하면 즉시 호출되어 처리되는 함수, 즉 사용자가 아닌 시스템이나 이벤트에 따라 호출 시점을 결정한다. 

<br><br><br>

## 🚩 3 - 5 코틀린의 다양한 함수

### 익명 함수

익명 함수란 **일반 함수이지만 이름이 없는 것**이다. 물론 람다식 함수도 이름 없이 구성할 수 있지만 익명 함수는 일반 함수의 이름을 생략하고 사용하는 것이다.

```kotlin
fun(x: Int, y: Int): Int = x + y // 함수 이름이 생략
```

이를 변수 선언에 그대로 사용할 수 있다.

```kotlin
val add: (Int, Int) -> Int = fun(x, y) = x + y // 익명 함수를 사용한 add 선언
val result = add(10, 2) // add의 사용
```

변수 `add`의 자료형은 람다식이고, 따라서 변수 `add`를 익명 함수를 사용해서 선언해주면 `add`는 람다식 함수처럼 `add()`와 같이 사용 가능하다. 

<br>

+ 익명 함수 사용

  `val add = fun(x: Int, y: Int) = x + y`

+ 람다식 표현법

  `val add = { x: Int, y: Int -> x + y}`

=> 둘 어떻게 구분 ? 람다는 `{ }` 중괄호? 익명 함수는 `fun` 키워드가 있음?

<br>

=> 그렇다면 람다식으로 표기할 수 있는데 굳이 익명 함수를 쓰는 이유는 ? 람다식에서는 return이나 break, continue처럼 제어문을 사용하기 어렵기 때문이다. 함수 본문 조건식에 따라 함수를 중단하고 반환해야 하는 경우에는 익명 함수를 사용해야 한다. 

<br><br>

### 인라인 함수

인라인 함수란 이 함수가 호출되는 곳에 함수 본문의 내용을 모두 복사해 넣어 함수의 분기 없이 처리되기 때문에 코드의 성능을 높일 수 있다. 인라인 함수는 코드가 복사되어 들어가기 때문에 내용은 대개 짧게 작성한다. **인라인 함수는 람다식 매개변수를 가지고 있는 함수에서 동작한다.**

보통 함수는 호출되었을 때 다른 코드로 분기해야 하기 때문에 내부적으로 기존 내용을 저장했다가 다시 돌아올 때 복구하는 작업에 프로세스(CPU)와 메모리를 꽤 사용해야 하는 비용(overhead)이 든다. 

+ 인라인 함수 제한하기

  ```kotlin
  inline fun sub(out1: ( ) -> Unit, noinline out2: ( ) -> Unit) { ~ }
  ```

  noinline 키워드를 사용하면 noinline이 있는 람다식은 인라인으로 처리되지 않고 분기하여 호출된다. 

<br><br>

### 확장 함수

클래스에는 다양한 함수가 정의되어 있다. 이것은 클래스의 멤버 메서드라고도 부른다. 그런데 기존 멤버 메서드는 아니지만 기존의 클래스에 내가 원하는 함수를 하나 더 포함시켜 확장하고 싶을 때가 있다. 코틀린에서는 클래스처럼 필요로 하는 대상에 함수를 더 추가할 수 있는 확장함수라는 개념을 제공한다. 

```kotlin
fun 확장대상.함수 이름(매개변수, ...): 반환값 {
    ...
    return 값
}
```

**코틀린의 모든 클래스에 내가 만들어 놓은 확장 함수를 추가**할 수 있을까? 

=> 최상위 클래스인 Any에 확장 함수를 구현하면 된다. 

<br>

##### String 클래스에 나만의 확장 함수 추가하기

```kotlin
// 길이가 더 긴 문자열을 반환하는 함수
fun String.getLongString(target: String): String = 
		if (this.length > target.length) this else target
```

+ if문에 있는 `this.length`의 this는 확장 대상에 있던 자리의 문자열인 String 객체를 나타낸다. 

=> 이렇게 확장 함수를 사용하면 **기존 클래스의 선언 구현부를 수정하지 않고 외부에서 손쉽게 기능을 확장**할 수 있다. 기존의 표준 라이브러리를 수정하지 않고도 확장할 수 있는 유용한 방법이다. 

<br><br>

### 중위함수

중위 표현법이란 클래스의 멤버를 호출할 때 사용하는 점(.)을 생략하고 함수 일음 뒤에 소괄호를 붙이지 않아 직관적인 이름을 사용할 수 있는 표현법이다. 즉, 중위 함수란 **일종의 연산자를 구현할 수 있는 함수**이다. 특히 비트 연산자에서 사용한다. 

중위함수의 조건

+ 멤버 메서드 또는 확장 함수여야 한다.
+ 하나의 매개변수를 가져야 한다.
+ infix 키워드를 사용하여 정의한다.

<br>

자료형 클래스인 Int에 확장 함수 `multifly()`를 만들고 이것을 중위 표현법으로 사용해 연산자처럼 만들어보자.

```kotlin
fun main(){
    // 일반 표현법
    // val multi = 3.multiplt(10)
    
    // 중위표현법
    val multi = 3 multiply 10
    println("multi: $multi") // multi: 30
}


// Int를 확장해서 multifly() 함수를 하나 더 추가함
infix fun Int.multifly(x:Int): Int { // infix로 선언되므로 중위함수
    return this * x
}
```

<br><br>

### 꼬리 재귀 함수

재귀 함수의 조건

+ 무한 호출에 빠지지 않도록 탈출 조건을 만들어야 한다
+ 스택 영역을 이용하므로 호출 횟수를 무리하게 많이 지정하지 않는다
+ 코드를 복잡하지 않게 한다

<br>

코틀린에서는 꼬리 재귀 함수(Tail Recursive Function)을 통해 스택 오버플로 현상을 해결할 수 있다. 이는 스택에 계속 쌓이는 방식이 아닌 꼬리를 무는 형태로 반복한다. 이 때 코틀린 고유의 `tailrec` 키워드를 사용해야 한다.

<br>

일반적인 재귀에서는 재귀 함수가 먼저 호출되고 계산되지만 꼬리 재귀에서는 계산을 먼저 하고 재귀 함수가 호출된다. 즉, 위 함수가 계산을 먼저 할 수 있도록 함수를 수정해야 한다.

<br><br><br>

## 🚩 3 - 6 함수와 변수의 범위

지역 함수를 사용할 때는 항상 지역 함수를 먼저 선언해야 한다. 지역 함수도 마찬가지로 블록이 끝나면 같이 삭제된다. 

